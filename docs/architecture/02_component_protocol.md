# Component Protocol

**Related:** [01_core_philosophy.md](01_core_philosophy.md) | [03_signal_backplane.md](03_signal_backplane.md) | [04_lifecycle.md](04_lifecycle.md)

---

Components are the atomic units of execution. They follow a **"Register Outputs, Wire Inputs"** pattern:

- **Outputs** are registered at Provision (intrinsic to the component)
- **Inputs** are wired at Stage (configurable per scenario)
- A **Data Dictionary** is auto-generated for discoverability

---

## 1. Register Outputs at Provision

Components declare what signals they produce. This is intrinsic—a JetEngine *is* a thing that produces thrust.

```cpp
template <typename Scalar>
class JetEngine : public Component<Scalar> {
    // Internal storage for outputs
    Scalar thrust_;
    Scalar fuel_flow_;
    Scalar spool_speed_;

    // Input handles (wired at Stage)
    SignalHandle<Scalar> input_altitude_;
    SignalHandle<Scalar> input_throttle_;

public:
    void Provision(Backplane<Scalar>& bp, const ComponentConfig& cfg) override {
        // Register OUTPUTS with metadata
        // Final name: {entity}.{component}.{signal} e.g., "X15.MainEngine.thrust"

        bp.register_output("thrust", &thrust_, {
            .units = "N",
            .description = "Net thrust force",
            .lifecycle = Lifecycle::Dynamic
        });

        bp.register_output("fuel_flow", &fuel_flow_, {
            .units = "kg/s",
            .description = "Fuel mass flow rate",
            .lifecycle = Lifecycle::Dynamic
        });

        bp.register_output("spool_speed", &spool_speed_, {
            .units = "rad/s",
            .description = "Turbine spool angular velocity",
            .lifecycle = Lifecycle::Dynamic,
            .integrable = true  // This is state—will be integrated
        });

        // Load static parameters
        max_thrust_ = cfg.get<double>("max_thrust", 50000.0);
        time_constant_ = cfg.get<double>("time_constant", 0.5);
    }

    void Stage(Backplane<Scalar>& bp, const ComponentConfig& cfg) override {
        // Wire INPUTS from config—these can point anywhere
        input_altitude_ = bp.resolve<Scalar>(cfg.get("input_altitude"));
        input_throttle_ = bp.resolve<Scalar>(cfg.get("input_throttle"));
    }

    void Step(Scalar t, Scalar dt) override {
        Scalar alt = *input_altitude_;
        Scalar throttle = *input_throttle_;

        // ... physics calculations ...

        thrust_ = calculated_thrust;  // Direct write to registered storage
        fuel_flow_ = calculated_fuel_flow;
    }
};
```

---

## 2. Wire Inputs at Stage

Config specifies where inputs come from—this is a wiring decision, not component identity.

```yaml
components:
  - type: JetEngine
    name: MainEngine
    entity: X15
    config:
      # INPUT WIRING: where to read from (fully flexible)
      input_altitude: "Environment.Atmosphere.Altitude"
      input_throttle: "Control.Throttle"

      # PARAMETERS: component configuration
      max_thrust: 75000.0
      time_constant: 0.5

      # Note: outputs are NOT specified here—they're intrinsic to JetEngine
      # Output signals will be: X15.MainEngine.thrust, X15.MainEngine.fuel_flow, etc.
```

---

## 3. Why This Split?

| Aspect | Outputs (Provision) | Inputs (Stage) |
| :--- | :--- | :--- |
| **Defined by** | Component code | Config file |
| **Rationale** | Identity—what the component *is* | Topology—how it's connected |
| **Flexibility** | Fixed per component type | Fully reconfigurable |
| **Example** | JetEngine always produces thrust | Altitude could come from sensor, model, or test harness |

> [!NOTE]
> **Outputs are identity. Inputs are topology.**
> A JetEngine without thrust isn't a JetEngine. But a JetEngine reading altitude from a barometer vs. GPS vs. truth model—that's just wiring.

---

## 4. Auto-Generated Data Dictionary

After Provision, the Simulator dumps all registered signals to a data dictionary file:

```cpp
void Simulator::Provision(const ScenarioConfig& cfg) {
    for (auto* comp : components_) {
        comp->Provision(backplane_, comp->config_);
    }

    // Generate data dictionary for tooling and documentation
    backplane_.GenerateDataDictionary("output/data_dictionary.yaml");
}
```

**Output: `data_dictionary.yaml`**

```yaml
# AUTO-GENERATED by Icarus Simulator
# Scenario: scenarios/x15_mission.yaml
# Generated: 2024-12-22T10:30:00Z
#
# This file documents all signals in the simulation.
# Use for: telemetry setup, recording config, debugging, documentation.

components:
  X15.MainEngine:
    type: JetEngine
    signals:
      thrust:
        type: double
        units: N
        lifecycle: dynamic
        description: "Net thrust force"

      fuel_flow:
        type: double
        units: kg/s
        lifecycle: dynamic
        description: "Fuel mass flow rate"

      spool_speed:
        type: double
        units: rad/s
        lifecycle: dynamic
        integrable: true
        description: "Turbine spool angular velocity"

  X15.Aero:
    type: AeroBody
    signals:
      lift:
        type: double
        units: N
        lifecycle: dynamic
        description: "Aerodynamic lift force"

      drag:
        type: double
        units: N
        lifecycle: dynamic
        description: "Aerodynamic drag force"

      alpha:
        type: double
        units: rad
        lifecycle: dynamic
        description: "Angle of attack"

  Environment.Atmosphere:
    type: StandardAtmosphere
    signals:
      Altitude:
        type: double
        units: m
        lifecycle: dynamic
        description: "Geometric altitude"

      Density:
        type: double
        units: kg/m³
        lifecycle: dynamic
        description: "Atmospheric density"

      Temperature:
        type: double
        units: K
        lifecycle: dynamic
        description: "Static air temperature"

# Summary
total_signals: 42
dynamic_signals: 38
static_signals: 4
integrable_states: 13
```

---

## 5. Data Dictionary Uses

| Use Case | How |
| :--- | :--- |
| **Telemetry Setup** | Select signals to stream by browsing dictionary |
| **Recording Config** | Reference signal names for `signals: ["X15.MainEngine.*"]` |
| **Debugging** | Know exactly what signals exist and their units |
| **Documentation** | Auto-generated, always up-to-date signal reference |
| **Tooling** | Daedalus UI reads dictionary for signal browser |
| **Validation** | Check config references against known signals |

---

## 6. Dependency Discovery

The Scheduler discovers dependencies by tracking Provision (outputs) and Stage (inputs):

```cpp
void Simulator::Stage(const RunConfig& rc) {
    DependencyGraph graph;

    // Outputs already registered during Provision
    for (auto* comp : components_) {
        for (const auto& out : comp->GetRegisteredOutputs()) {
            graph.AddProvider(out.full_name, comp);
        }
    }

    // Track input resolution during Stage
    for (auto* comp : components_) {
        backplane_.BeginTracking();
        comp->Stage(backplane_, comp->config_);

        for (const auto& in : backplane_.GetTrackedInputs()) {
            graph.AddDependency(in.signal_name, comp);
        }
        backplane_.EndTracking();
    }

    // Topological sort for execution order
    execution_order_ = graph.TopologicalSort();  // Throws on cycle
}
```

---

## 7. Validation

| Validation | When | Error Example |
| :--- | :--- | :--- |
| Signal exists | `resolve()` at Stage | `"Env.Atm.Altidude" not found. Did you mean "X15.Atm.Altitude"?` |
| Type matches | `resolve<T>()` at Stage | `"gnc.mode" is int32, but requested double` |
| No duplicate outputs | `register_output()` at Provision | `"thrust" already registered by LeftEngine` |
| No dependency cycles | End of Stage | `Cycle detected: A → B → C → A` |
| Config key exists | `cfg.get()` | `"input_altitude" not specified for X15.MainEngine` |

---

## 8. Aggregation Registration

Some quantities require **global aggregation**—summing contributions from many components. Components **opt-in** by registering as sources during Provision.

> [!NOTE]
> **See [12_quantity_aggregation.md](12_quantity_aggregation.md) for complete implementation details.**

### Force Sources

Components that produce forces register them with frame metadata:

```cpp
template <typename Scalar>
void RocketEngine<Scalar>::Provision(Backplane<Scalar>& bp, const ComponentConfig& cfg) {
    // Standard output registration
    bp.register_output("thrust", &thrust_mag_, {.units = "N"});

    // Force source registration (opt-in for aggregation)
    bp.register_force_source({
        .name = full_name_ + ".thrust",
        .force = &thrust_force_,         // Force vector
        .moment = &thrust_moment_,        // Moment about application point
        .frame = Frame::LOCAL,            // BODY, WIND, LOCAL, or INERTIAL
        .application_point = &nozzle_pos_,
        .dcm_to_body = &nozzle_dcm_,      // Required for LOCAL frame
        .entity_active = entity_active_ptr_
    });
}
```

### Mass Sources

Components with mass contribute to total mass, CG, and inertia:

```cpp
template <typename Scalar>
void FuelTank<Scalar>::Provision(Backplane<Scalar>& bp, const ComponentConfig& cfg) {
    bp.register_output("fuel_mass", &fuel_mass_, {.units = "kg"});

    bp.register_mass_source({
        .name = full_name_ + ".fuel",
        .mass = &fuel_mass_,             // Can be dynamic (depleting)
        .cg_body = &fuel_cg_,            // CG in body frame
        .inertia_cg = nullptr,           // Often negligible for liquids
        .lifecycle = Lifecycle::DYNAMIC,
        .entity_active = entity_active_ptr_
    });
}
```

### Why Registration (Not Base Class)?

| Approach | Problem |
|:---------|:--------|
| **Bake into Component** | Forces every component to define force/mass even when N/A |
| **Virtual getForce()** | Breaks symbolic mode (CasADi can't trace through vtables) |
| **Registration** | Opt-in, explicit, traceable, symbolic-compatible |

### Aggregation Summary

| Quantity | Aggregated By | Consumed By |
|:---------|:--------------|:------------|
| Forces/Moments | `ForceAggregator` | EOM |
| Mass/CG/Inertia | `MassAggregator` | EOM, ForceAggregator |

Components without forces or mass (e.g., `Autopilot`, `IMU`, `Telemetry`) simply don't register—no overhead, no boilerplate.
